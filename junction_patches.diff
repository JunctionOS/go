diff --git a/src/cmd/vendor/golang.org/x/sys/unix/asm_junction_amd64.s b/src/cmd/vendor/golang.org/x/sys/unix/asm_junction_amd64.s
index 73650daf6f..34192852f8 100644
--- a/src/cmd/vendor/golang.org/x/sys/unix/asm_junction_amd64.s
+++ b/src/cmd/vendor/golang.org/x/sys/unix/asm_junction_amd64.s
@@ -24,11 +24,15 @@ TEXT ·SyscallNoError(SB),NOSPLIT,$0-48
 	MOVQ	a1+8(FP), DI
 	MOVQ	a2+16(FP), SI
 	MOVQ	a3+24(FP), DX
-	MOVQ	$0, R10
+	MOVQ	$0, CX
 	MOVQ	$0, R8
 	MOVQ	$0, R9
 	MOVQ	trap+0(FP), AX	// syscall entry
-	SYSCALL
+
+	PUSHQ AX
+	CALL (0x200e18)
+	POPQ R10
+
 	MOVQ	AX, r1+32(FP)
 	MOVQ	DX, r2+40(FP)
 	CALL	runtime·exitsyscall(SB)
@@ -44,11 +48,15 @@ TEXT ·RawSyscallNoError(SB),NOSPLIT,$0-48
 	MOVQ	a1+8(FP), DI
 	MOVQ	a2+16(FP), SI
 	MOVQ	a3+24(FP), DX
-	MOVQ	$0, R10
+	MOVQ	$0, CX
 	MOVQ	$0, R8
 	MOVQ	$0, R9
 	MOVQ	trap+0(FP), AX	// syscall entry
-	SYSCALL
+
+	PUSHQ AX
+	CALL (0x200e18)
+	POPQ R10
+
 	MOVQ	AX, r1+32(FP)
 	MOVQ	DX, r2+40(FP)
 	RET
diff --git a/src/internal/goos/zgoos_junction.go b/src/internal/goos/zgoos_junction.go
index 87bf8bcdc5..a625ac01c8 100644
--- a/src/internal/goos/zgoos_junction.go
+++ b/src/internal/goos/zgoos_junction.go
@@ -4,7 +4,7 @@
 
 package goos
 
-const GOOS = `linux`
+const GOOS = `junction`
 
 const IsAix = 0
 const IsAndroid = 0
diff --git a/src/internal/runtime/syscall/asm_junction_amd64.s b/src/internal/runtime/syscall/asm_junction_amd64.s
index c2d0b12ea2..47f4b7db1a 100644
--- a/src/internal/runtime/syscall/asm_junction_amd64.s
+++ b/src/internal/runtime/syscall/asm_junction_amd64.s
@@ -28,12 +28,13 @@
 TEXT ·Syscall6<ABIInternal>(SB),NOSPLIT,$0
 	// a6 already in R9.
 	// a5 already in R8.
-	MOVQ	SI, R10 // a4
+	XCHGQ	SI, CX
 	MOVQ	DI, DX  // a3
-	MOVQ	CX, SI  // a2
 	MOVQ	BX, DI  // a1
 	// num already in AX.
-	SYSCALL
+	PUSHQ   AX
+	CALL (0x200e18)
+	POPQ    SI
 	CMPQ	AX, $0xfffffffffffff001
 	JLS	ok
 	NEGQ	AX
diff --git a/src/runtime/sys_junction_amd64.s b/src/runtime/sys_junction_amd64.s
index c4d33ad2c2..d2c74d98da 100644
--- a/src/runtime/sys_junction_amd64.s
+++ b/src/runtime/sys_junction_amd64.s
@@ -49,31 +49,35 @@
 #define SYS_faccessat		269
 #define SYS_pipe2		293
 
+#define SYSCALL \
+	CALL (0x200e18); \
+	POPQ	SI;
+
 TEXT runtime·exit(SB),NOSPLIT,$0-4
 	MOVL	code+0(FP), DI
-	MOVL	$SYS_exit_group, AX
+	PUSHQ	$SYS_exit_group
 	SYSCALL
 	RET
 
 // func exitThread(wait *atomic.Uint32)
-TEXT runtime·exitThread(SB),NOSPLIT,$0-8
+TEXT runtime·exitThread(SB),NOSPLIT|NOFRAME,$0-8
 	MOVQ	wait+0(FP), AX
 	// We're done using the stack.
 	MOVL	$0, (AX)
 	MOVL	$0, DI	// exit code
-	MOVL	$SYS_exit, AX
+	PUSHQ	$SYS_exit
 	SYSCALL
 	// We may not even have a stack any more.
 	INT	$3
 	JMP	0(PC)
 
-TEXT runtime·open(SB),NOSPLIT,$0-20
+TEXT runtime·open(SB),NOSPLIT|NOFRAME,$0-20
 	// This uses openat instead of open, because Android O blocks open.
 	MOVL	$AT_FDCWD, DI // AT_FDCWD, so this acts like open
 	MOVQ	name+0(FP), SI
 	MOVL	mode+8(FP), DX
-	MOVL	perm+12(FP), R10
-	MOVL	$SYS_openat, AX
+	MOVL	perm+12(FP), CX
+	PUSHQ	$SYS_openat
 	SYSCALL
 	CMPQ	AX, $0xfffffffffffff001
 	JLS	2(PC)
@@ -81,9 +85,9 @@ TEXT runtime·open(SB),NOSPLIT,$0-20
 	MOVL	AX, ret+16(FP)
 	RET
 
-TEXT runtime·closefd(SB),NOSPLIT,$0-12
+TEXT runtime·closefd(SB),NOSPLIT|NOFRAME,$0-12
 	MOVL	fd+0(FP), DI
-	MOVL	$SYS_close, AX
+	PUSHQ	$SYS_close
 	SYSCALL
 	CMPQ	AX, $0xfffffffffffff001
 	JLS	2(PC)
@@ -91,29 +95,29 @@ TEXT runtime·closefd(SB),NOSPLIT,$0-12
 	MOVL	AX, ret+8(FP)
 	RET
 
-TEXT runtime·write1(SB),NOSPLIT,$0-28
+TEXT runtime·write1(SB),NOSPLIT|NOFRAME,$0-28
 	MOVQ	fd+0(FP), DI
 	MOVQ	p+8(FP), SI
 	MOVL	n+16(FP), DX
-	MOVL	$SYS_write, AX
+	PUSHQ	$SYS_write
 	SYSCALL
 	MOVL	AX, ret+24(FP)
 	RET
 
-TEXT runtime·read(SB),NOSPLIT,$0-28
+TEXT runtime·read(SB),NOSPLIT|NOFRAME,$0-28
 	MOVL	fd+0(FP), DI
 	MOVQ	p+8(FP), SI
 	MOVL	n+16(FP), DX
-	MOVL	$SYS_read, AX
+	PUSHQ	$SYS_read
 	SYSCALL
 	MOVL	AX, ret+24(FP)
 	RET
 
 // func pipe2(flags int32) (r, w int32, errno int32)
-TEXT runtime·pipe2(SB),NOSPLIT,$0-20
+TEXT runtime·pipe2(SB),NOSPLIT|NOFRAME,$0-20
 	LEAQ	r+8(FP), DI
 	MOVL	flags+0(FP), SI
-	MOVL	$SYS_pipe2, AX
+	PUSHQ	$SYS_pipe2
 	SYSCALL
 	MOVL	AX, errno+16(FP)
 	RET
@@ -131,49 +135,49 @@ TEXT runtime·usleep(SB),NOSPLIT,$16
 	// nanosleep(&ts, 0)
 	MOVQ	SP, DI
 	MOVL	$0, SI
-	MOVL	$SYS_nanosleep, AX
+	PUSHQ	$SYS_nanosleep
 	SYSCALL
 	RET
 
 TEXT runtime·gettid(SB),NOSPLIT,$0-4
-	MOVL	$SYS_gettid, AX
+	PUSHQ	$SYS_gettid
 	SYSCALL
 	MOVL	AX, ret+0(FP)
 	RET
 
 TEXT runtime·raise(SB),NOSPLIT,$0
-	MOVL	$SYS_getpid, AX
+	PUSHQ	$SYS_getpid
 	SYSCALL
 	MOVL	AX, R12
-	MOVL	$SYS_gettid, AX
+	PUSHQ	$SYS_gettid
 	SYSCALL
 	MOVL	AX, SI	// arg 2 tid
 	MOVL	R12, DI	// arg 1 pid
 	MOVL	sig+0(FP), DX	// arg 3
-	MOVL	$SYS_tgkill, AX
+	PUSHQ	$SYS_tgkill
 	SYSCALL
 	RET
 
 TEXT runtime·raiseproc(SB),NOSPLIT,$0
-	MOVL	$SYS_getpid, AX
+	PUSHQ	$SYS_getpid
 	SYSCALL
 	MOVL	AX, DI	// arg 1 pid
 	MOVL	sig+0(FP), SI	// arg 2
-	MOVL	$SYS_kill, AX
+	PUSHQ	$SYS_kill
 	SYSCALL
 	RET
 
 TEXT ·getpid(SB),NOSPLIT,$0-8
-	MOVL	$SYS_getpid, AX
+	PUSHQ	$SYS_getpid
 	SYSCALL
 	MOVQ	AX, ret+0(FP)
 	RET
 
-TEXT ·tgkill(SB),NOSPLIT,$0
+TEXT ·tgkill(SB),NOSPLIT|NOFRAME,$0
 	MOVQ	tgid+0(FP), DI
 	MOVQ	tid+8(FP), SI
 	MOVQ	sig+16(FP), DX
-	MOVL	$SYS_tgkill, AX
+	PUSHQ	$SYS_tgkill
 	SYSCALL
 	RET
 
@@ -181,41 +185,41 @@ TEXT runtime·setitimer(SB),NOSPLIT,$0-24
 	MOVL	mode+0(FP), DI
 	MOVQ	new+8(FP), SI
 	MOVQ	old+16(FP), DX
-	MOVL	$SYS_setittimer, AX
+	PUSHQ	$SYS_setittimer
 	SYSCALL
 	RET
 
-TEXT runtime·timer_create(SB),NOSPLIT,$0-28
+TEXT runtime·timer_create(SB),NOSPLIT|NOFRAME,$0-28
 	MOVL	clockid+0(FP), DI
 	MOVQ	sevp+8(FP), SI
 	MOVQ	timerid+16(FP), DX
-	MOVL	$SYS_timer_create, AX
+	PUSHQ	$SYS_timer_create
 	SYSCALL
 	MOVL	AX, ret+24(FP)
 	RET
 
-TEXT runtime·timer_settime(SB),NOSPLIT,$0-28
+TEXT runtime·timer_settime(SB),NOSPLIT|NOFRAME,$0-28
 	MOVL	timerid+0(FP), DI
 	MOVL	flags+4(FP), SI
 	MOVQ	new+8(FP), DX
-	MOVQ	old+16(FP), R10
-	MOVL	$SYS_timer_settime, AX
+	MOVQ	old+16(FP), CX
+	PUSHQ	$SYS_timer_settime
 	SYSCALL
 	MOVL	AX, ret+24(FP)
 	RET
 
-TEXT runtime·timer_delete(SB),NOSPLIT,$0-12
+TEXT runtime·timer_delete(SB),NOSPLIT|NOFRAME,$0-12
 	MOVL	timerid+0(FP), DI
-	MOVL	$SYS_timer_delete, AX
+	PUSHQ	$SYS_timer_delete
 	SYSCALL
 	MOVL	AX, ret+8(FP)
 	RET
 
-TEXT runtime·mincore(SB),NOSPLIT,$0-28
+TEXT runtime·mincore(SB),NOSPLIT|NOFRAME,$0-28
 	MOVQ	addr+0(FP), DI
 	MOVQ	n+8(FP), SI
 	MOVQ	dst+16(FP), DX
-	MOVL	$SYS_mincore, AX
+	PUSHQ	$SYS_mincore
 	SYSCALL
 	MOVL	AX, ret+24(FP)
 	RET
@@ -282,7 +286,7 @@ ret:
 	MOVQ	AX, ret+0(FP)
 	RET
 fallback:
-	MOVQ	$SYS_clock_gettime, AX
+	PUSHQ	$SYS_clock_gettime
 	SYSCALL
 	JMP	ret
 
@@ -290,20 +294,20 @@ TEXT runtime·rtsigprocmask(SB),NOSPLIT,$0-28
 	MOVL	how+0(FP), DI
 	MOVQ	new+8(FP), SI
 	MOVQ	old+16(FP), DX
-	MOVL	size+24(FP), R10
-	MOVL	$SYS_rt_sigprocmask, AX
+	MOVL	size+24(FP), CX
+	PUSHQ	$SYS_rt_sigprocmask
 	SYSCALL
 	CMPQ	AX, $0xfffffffffffff001
 	JLS	2(PC)
 	MOVL	$0xf1, 0xf1  // crash
 	RET
 
-TEXT runtime·rt_sigaction(SB),NOSPLIT,$0-36
+TEXT runtime·rt_sigaction(SB),NOSPLIT|NOFRAME,$0-36
 	MOVQ	sig+0(FP), DI
 	MOVQ	new+8(FP), SI
 	MOVQ	old+16(FP), DX
-	MOVQ	size+24(FP), R10
-	MOVL	$SYS_rt_sigaction, AX
+	MOVQ	size+24(FP), CX
+	PUSHQ	$SYS_rt_sigaction
 	SYSCALL
 	MOVL	AX, ret+32(FP)
 	RET
@@ -469,19 +473,18 @@ sigtrampnog:
 // the name. The gdb source code is:
 // https://sourceware.org/git/?p=binutils-gdb.git;a=blob;f=gdb/amd64-linux-tdep.c;h=cbbac1a0c64e1deb8181b9d0ff6404e328e2979d#l178
 TEXT runtime·sigreturn__sigaction(SB),NOSPLIT,$0
-	MOVQ	$SYS_rt_sigreturn, AX
-	SYSCALL
+	JMP (0x200078)
 	INT $3	// not reached
 
 TEXT runtime·sysMmap(SB),NOSPLIT,$0
 	MOVQ	addr+0(FP), DI
 	MOVQ	n+8(FP), SI
 	MOVL	prot+16(FP), DX
-	MOVL	flags+20(FP), R10
+	MOVL	flags+20(FP), CX
 	MOVL	fd+24(FP), R8
 	MOVL	off+28(FP), R9
 
-	MOVL	$SYS_mmap, AX
+	PUSHQ	$SYS_mmap
 	SYSCALL
 	CMPQ	AX, $0xfffffffffffff001
 	JLS	ok
@@ -516,7 +519,7 @@ TEXT runtime·callCgoMmap(SB),NOSPLIT,$16
 TEXT runtime·sysMunmap(SB),NOSPLIT,$0
 	MOVQ	addr+0(FP), DI
 	MOVQ	n+8(FP), SI
-	MOVQ	$SYS_munmap, AX
+	PUSHQ	$SYS_munmap
 	SYSCALL
 	CMPQ	AX, $0xfffffffffffff001
 	JLS	2(PC)
@@ -536,11 +539,11 @@ TEXT runtime·callCgoMunmap(SB),NOSPLIT,$16-16
 	MOVQ	0(SP), SP
 	RET
 
-TEXT runtime·madvise(SB),NOSPLIT,$0
+TEXT runtime·madvise(SB),NOSPLIT|NOFRAME,$0
 	MOVQ	addr+0(FP), DI
 	MOVQ	n+8(FP), SI
 	MOVL	flags+16(FP), DX
-	MOVQ	$SYS_madvise, AX
+	PUSHQ	$SYS_madvise
 	SYSCALL
 	MOVL	AX, ret+24(FP)
 	RET
@@ -551,10 +554,10 @@ TEXT runtime·futex(SB),NOSPLIT,$0
 	MOVQ	addr+0(FP), DI
 	MOVL	op+8(FP), SI
 	MOVL	val+12(FP), DX
-	MOVQ	ts+16(FP), R10
+	MOVQ	ts+16(FP), CX
 	MOVQ	addr2+24(FP), R8
 	MOVL	val3+32(FP), R9
-	MOVL	$SYS_futex, AX
+	PUSHQ	$SYS_futex
 	SYSCALL
 	MOVL	AX, ret+40(FP)
 	RET
@@ -563,17 +566,17 @@ TEXT runtime·futex(SB),NOSPLIT,$0
 TEXT runtime·clone(SB),NOSPLIT|NOFRAME,$0
 	MOVL	flags+0(FP), DI
 	MOVQ	stk+8(FP), SI
-	MOVQ	$0, DX
-	MOVQ	$0, R10
-	MOVQ    $0, R8
+	XORQ DX,DX
+	XORQ CX,CX
+	XORQ R8,R8
 	// Copy mp, gp, fn off parent stack for use by child.
 	// Careful: Linux system call clobbers CX and R11.
 	MOVQ	mp+16(FP), R13
-	MOVQ	gp+24(FP), R9
+	MOVQ	gp+24(FP), R15
 	MOVQ	fn+32(FP), R12
 	CMPQ	R13, $0    // m
 	JEQ	nog1
-	CMPQ	R9, $0    // g
+	CMPQ	R15, $0    // g
 	JEQ	nog1
 	LEAQ	m_tls(R13), R8
 #ifdef GOOS_android
@@ -585,7 +588,7 @@ TEXT runtime·clone(SB),NOSPLIT|NOFRAME,$0
 	ORQ 	$0x00080000, DI //add flag CLONE_SETTLS(0x00080000) to call clone
 nog1:
 	MOVL	$SYS_clone, AX
-	SYSCALL
+	CALL (0x200e20)
 
 	// In parent, return.
 	CMPQ	AX, $0
@@ -599,19 +602,19 @@ nog1:
 	// If g or m are nil, skip Go-related setup.
 	CMPQ	R13, $0    // m
 	JEQ	nog2
-	CMPQ	R9, $0    // g
+	CMPQ	R15, $0    // g
 	JEQ	nog2
 
 	// Initialize m->procid to Linux tid
-	MOVL	$SYS_gettid, AX
+	PUSHQ	$SYS_gettid
 	SYSCALL
 	MOVQ	AX, m_procid(R13)
 
 	// In child, set up new stack
 	get_tls(CX)
-	MOVQ	R13, g_m(R9)
-	MOVQ	R9, g(CX)
-	MOVQ	R9, R14 // set g register
+	MOVQ	R13, g_m(R15)
+	MOVQ	R15, g(CX)
+	MOVQ	R15, R14 // set g register
 	CALL	runtime·stackcheck(SB)
 
 nog2:
@@ -620,14 +623,14 @@ nog2:
 
 	// It shouldn't return. If it does, exit that thread.
 	MOVL	$111, DI
-	MOVL	$SYS_exit, AX
+	PUSHQ	$SYS_exit
 	SYSCALL
 	JMP	-3(PC)	// keep exiting
 
 TEXT runtime·sigaltstack(SB),NOSPLIT,$0
 	MOVQ	new+0(FP), DI
 	MOVQ	old+8(FP), SI
-	MOVQ	$SYS_sigaltstack, AX
+	PUSHQ	$SYS_sigaltstack
 	SYSCALL
 	CMPQ	AX, $0xfffffffffffff001
 	JLS	2(PC)
@@ -644,7 +647,7 @@ TEXT runtime·settls(SB),NOSPLIT,$32
 #endif
 	MOVQ	DI, SI
 	MOVQ	$0x1002, DI	// ARCH_SET_FS
-	MOVQ	$SYS_arch_prctl, AX
+	PUSHQ	$SYS_arch_prctl
 	SYSCALL
 	CMPQ	AX, $0xfffffffffffff001
 	JLS	2(PC)
@@ -652,7 +655,7 @@ TEXT runtime·settls(SB),NOSPLIT,$32
 	RET
 
 TEXT runtime·osyield(SB),NOSPLIT,$0
-	MOVL	$SYS_sched_yield, AX
+	PUSHQ	$SYS_sched_yield
 	SYSCALL
 	RET
 
@@ -660,7 +663,7 @@ TEXT runtime·sched_getaffinity(SB),NOSPLIT,$0
 	MOVQ	pid+0(FP), DI
 	MOVQ	len+8(FP), SI
 	MOVQ	buf+16(FP), DX
-	MOVL	$SYS_sched_getaffinity, AX
+	PUSHQ	$SYS_sched_getaffinity
 	SYSCALL
 	MOVL	AX, ret+24(FP)
 	RET
@@ -671,8 +674,8 @@ TEXT runtime·access(SB),NOSPLIT,$0
 	MOVL	$AT_FDCWD, DI // AT_FDCWD, so this acts like access
 	MOVQ	name+0(FP), SI
 	MOVL	mode+8(FP), DX
-	MOVL	$0, R10
-	MOVL	$SYS_faccessat, AX
+	MOVL	$0, CX
+	PUSHQ	$SYS_faccessat
 	SYSCALL
 	MOVL	AX, ret+16(FP)
 	RET
@@ -682,7 +685,7 @@ TEXT runtime·connect(SB),NOSPLIT,$0-28
 	MOVL	fd+0(FP), DI
 	MOVQ	addr+8(FP), SI
 	MOVL	len+16(FP), DX
-	MOVL	$SYS_connect, AX
+	PUSHQ	$SYS_connect
 	SYSCALL
 	MOVL	AX, ret+24(FP)
 	RET
@@ -692,7 +695,7 @@ TEXT runtime·socket(SB),NOSPLIT,$0-20
 	MOVL	domain+0(FP), DI
 	MOVL	typ+4(FP), SI
 	MOVL	prot+8(FP), DX
-	MOVL	$SYS_socket, AX
+	PUSHQ	$SYS_socket
 	SYSCALL
 	MOVL	AX, ret+16(FP)
 	RET
@@ -701,7 +704,7 @@ TEXT runtime·socket(SB),NOSPLIT,$0-20
 TEXT runtime·sbrk0(SB),NOSPLIT,$0-8
 	// Implemented as brk(NULL).
 	MOVQ	$0, DI
-	MOVL	$SYS_brk, AX
+	PUSHQ	$SYS_brk
 	SYSCALL
 	MOVQ	AX, ret+0(FP)
 	RET
diff --git a/src/runtime/time_junction_amd64.s b/src/runtime/time_junction_amd64.s
index b87843818f..7ccf3a01b6 100644
--- a/src/runtime/time_junction_amd64.s
+++ b/src/runtime/time_junction_amd64.s
@@ -8,6 +8,10 @@
 #include "go_tls.h"
 #include "textflag.h"
 
+#define SYSCALL \
+	CALL (0x200e18); \
+	POPQ SI;
+
 #define SYS_clock_gettime	228
 
 // func now() (sec int64, nsec int32, mono int64)
@@ -76,12 +80,12 @@ ret:
 	RET
 
 fallback:
-	MOVQ	$SYS_clock_gettime, AX
+	PUSHQ	$SYS_clock_gettime
 	SYSCALL
 
 	MOVL	$1, DI // CLOCK_MONOTONIC
 	LEAQ	0(SP), SI
-	MOVQ	$SYS_clock_gettime, AX
+	PUSHQ	$SYS_clock_gettime
 	SYSCALL
 
 	JMP	ret
diff --git a/src/syscall/asm_junction_amd64.s b/src/syscall/asm_junction_amd64.s
index 3d4436187d..a3c3e925ff 100644
--- a/src/syscall/asm_junction_amd64.s
+++ b/src/syscall/asm_junction_amd64.s
@@ -10,6 +10,10 @@
 // System calls for AMD64, Linux
 //
 
+#define SYSCALL \
+	CALL (0x200e18); \
+	POPQ R10;
+
 #define SYS_gettimeofday 96
 
 // func rawVforkSyscall(trap, a1, a2, a3 uintptr) (r1, err uintptr)
@@ -17,12 +21,12 @@ TEXT ·rawVforkSyscall(SB),NOSPLIT|NOFRAME,$0-48
 	MOVQ	a1+8(FP), DI
 	MOVQ	a2+16(FP), SI
 	MOVQ	a3+24(FP), DX
-	MOVQ	$0, R10
+	MOVQ	$0, CX
 	MOVQ	$0, R8
 	MOVQ	$0, R9
 	MOVQ	trap+0(FP), AX	// syscall entry
 	POPQ	R12 // preserve return address
-	SYSCALL
+	CALL (0x200e20)
 	PUSHQ	R12
 	CMPQ	AX, $0xfffffffffffff001
 	JLS	ok2
@@ -41,6 +45,7 @@ TEXT ·rawSyscallNoError(SB),NOSPLIT,$0-48
 	MOVQ	a2+16(FP), SI
 	MOVQ	a3+24(FP), DX
 	MOVQ	trap+0(FP), AX	// syscall entry
+	PUSHQ AX
 	SYSCALL
 	MOVQ	AX, r1+32(FP)
 	MOVQ	DX, r2+40(FP)
@@ -61,7 +66,7 @@ ret:
 	MOVQ	AX, err+8(FP)
 	RET
 fallback:
-	MOVL	$SYS_gettimeofday, AX
+	PUSHQ	$SYS_gettimeofday
 	SYSCALL
 	JMP ret
 ok7:
